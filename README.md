# Jet's Island

Setetup steps for next js application from scratch and online business "Jet's Island" presentation.

## Architecture

This section will include all steps and packages needed to setup the codebase.

### Installation

First, the next.js project needs to be initialized. Make sure you have node installed locally, then run the create-next-app command with the --ts flag, for TypeScript. You can also add the . if you wish to install in the current folder, instead of creating a new one.

```
npx create-next-app@latest --ts .
```

### Engine locking

First, we will define the fact that this project is designed to be built and run with yarn (the default for create-next-app, instead of npm). We already initialized the project with yarn during the initial step, and a .yarnlock file was autogenerated.

##### .npmrc

We will create a .npmrc file, where we specify that the engine that we defined (yarn / npm) must strictly be used when workgin with this project

```
engine-strict=true
```

##### .nvmrc

We will create a .nvmrc to clarify which version of node we are using

```
v16.13.1
```

Depending on your needs, you may need to use an older node version (e.g. if you want to deploy on something like vercel, you may need to use a speciffic or older node version)

##### "engines" field to package.json

Add the following engine to the package.json file; with this engine locking in place, if someone tries to run 'npm install', which could create a package.lock file and cause conflicts, an error will be thrown.

### Eslint

By default, eslint also come preconfigured in the next app, so you can already run `yarn lint` and it will work, but we do want to add more configurations to make it a bit more strict.

The .eslint.json file already extends next/core-web-vitals, we will turn this into an array and add next and eslint/recommended

```
{
  "extends": [
    "next",
    "next/core-web-vitals",
    "eslint:recommended"
  ]
}
```

When using react version 17 or newer, the React object is global, so you no longer need to import it in the scope of your components; to tell the linter that it does not need to warn us that we are using a variable that is not defined, we will add React it to the "globals" key:

```
{
  "globals": {
    "React": "readonly"
  }
}
```

Lastly, we will add an entry for rules, where we can manually turn on/off different rules we like / don't like. For example, we can set the no-unused-vars to X (0 = ok, 1 = warning, 2 = error) and make it ignore variables prefixed with "\_":

```
{
  "rules": {
    "no-unused-vars": [1, { "args": "after-used", "argsIgnorePattern": "^_" }]
  }
}
```

### Prettier

For code formatting, we will install prettier as a dev dependency.

```
yarn add -D prettier
```

With VS Code it is also highly recommended to use the prettier extension: https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode, which will allow your editor to automatically format the code (e.g. on save), instead of relying on the command line tool.

##### .prettierignore

Used to set patterns of files and folders that we do not prettier to format:

```
.yarn
.next
dist
node_modules
```

##### .prettierrc

Can also be named .prettierrc.json, used to create rules for formatting code. Like thie .prettierignore, this file will also be used by both the "prettier" command, and the vs code plugin.

```
{
  "trailingComma": "all",
  "tabWidth": 4,
  "semi": false,
  "singleQuote": true,
  "printWidth": 120,
  "overrides": [
    {
      "files": ["*.json", ".prettierrc"],
      "options": {
        "tabWidth": 2
      }
    },
    {
      "files": ["paths.ts", "apis.ts", "urls.ts"],
      "options": {
        "printWidth": 140
      }
    }
  ]
}
```

##### Add command to package.json

Adding amd running this script to the package.json file will enforce the code formatting rules (.prettierrc) on all files, except the ignored ones (.prettierignore). The --write flag is used to also save the files after changing them, and the . means to run in the whole project directory:

```
{
  "scripts": {
    "prettier": "prettier --write ."
  }
}
```

##### Personal settings.json file

I presonally have this configuration in my settings.json file, I prefer to only format on save and not on paste/type, and I also use a plugin called "Formatting Toggle" https://marketplace.visualstudio.com/items?itemName=tombonnike.vscode-status-bar-format-toggle, for situations where I need to turn off formatOnX (only the values in "formattingToggle.affects" will be affected, formatOnSave in my case as it is the only one that is't always set to false). Setting "prettier.requireConfig" to true will also only format projects that have a .prettierrc file, and not just everything.

```
{
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": true,
  "editor.formatOnPaste": false,
  "editor.formatOnType": false,
  "formattingToggle.affects": ["formatOnSave"],
  "prettier.requireConfig": false, // Only format projects with Prettier config file
  "editor.tabSize": 4, // In sync with value from .prittierrc file
}
```

### Git hooks

Git hooks are scripts that run at different stages of the git process (commit, push, etc.). If the scripts fail, the git action is not completd. For example, you can make sure that the linter will pass before finishing the commit, or that the app can be successfully built before pushing the code to remote.

First, we need to install husky:

```
yarn add -D husky
```

Then, we need to initialize it. Running the husky install command will generate a .husky folder in our project; all scripts created here will be executed for all contributing developers:

```
npx husky install
```

!IMPORTANT! When creating a hook for the first time, it is highly recommended to use the cli commands (e.g. npx husky add...), as manually creating / copying the files can result in git related errors

##### pre-commit hook

To create a hook that runs each time we commit to the project, we need to add to "pre-commit"; here, we can add the "yarn lint" script to make sure that there are no linter errors before commiting

```
npx husky add .husky/pre-commit "yarn lint"
```

##### pre-push hook

To create a hook that runs each time we push to origin, we need to add to "pre-push"; here, er can add the "yarn build" script to make sure that the app can be successfully build before pushing.

```
npx husky add .husky/pre-push "yarn build"
```

##### prepare script

The prepare script will also need to be added to package.json.

When other people clone the project and run yarn install, this script it will also automatically install husky to make sure they all are making use of the git hooks.

```
"prepare": "husky install"
```

#### Debugging:

Check that git config core.hooksPath returns .husky (or your custom hooks directory):

```
git config core.hooksPath
```

Update git version:

```
git --version
git update-git-for-windows
```

##### Workaround for Windows 10, Git Bash and Yarn

Git hooks may fail when using Yarn on Windows with Git Bash (stdin is not a tty). If you have users on Windows, it's highly recommended to add the following workaround.
https://typicode.github.io/husky/#/?id=yarn-on-windows

1. Create .husky/common.sh:

```
command_exists () {
  command -v "$1" >/dev/null 2>&1
}

# Workaround for Windows 10, Git Bash and Yarn
if command_exists winpty && test -t 1; then
  exec < /dev/tty
fi
```

2. Source it in in places where Yarn is used to run commands:

```
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"
. "$(dirname -- "$0")/common.sh"

yarn ...
```

### Commit messages linter

To make sure commit messages follow a convention, we can add commitlint. First, install as dev dependencies:

```
yarn add -D @commitlint/config-conventional
yarn add -D @commitlint/cli
```

In order to customise this linter we need to create a file named `commitlint.config.js`. This file is not necessary, or if you do use it it's usually enough just to extend @commitlint/config-conventional, however for this repo we will also manually add all the rules that come in from @commitlint/config-conventional, just to see what they are, and to have a clear list of all prefixes allowed:

```
module.exports = {
    extends: ['@commitlint/config-conventional'],
    rules: {
        'body-leading-blank': [1, 'always'],
        'body-max-line-length': [2, 'always', 100],
        'footer-leading-blank': [1, 'always'],
        'footer-max-line-length': [2, 'always', 100],
        'header-max-length': [2, 'always', 100],
        'scope-case': [2, 'always', 'lower-case'],
        'subject-case': [2, 'never', ['sentence-case', 'start-case', 'pascal-case', 'upper-case']],
        'subject-empty': [2, 'never'],
        'subject-full-stop': [2, 'never', '.'],
        'type-case': [2, 'always', 'lower-case'],
        'type-empty': [2, 'never'],
        'type-enum': [
            2,
            'always',
            [
                'build',
                'chore',
                'ci',
                'docs',
                'feat',
                'fix',
                'perf',
                'refactor',
                'revert',
                'style',
                'test',
                'translation',
                'security',
                'changeset',
            ],
        ],
    },
}
```

Lastly, in order for it to actually work we need to enavble it with husky:

```
npx husky add .husky/commit-msg 'npx --no -- commitlint --edit "$1"'
```

```
# Sometimes above command doesn't work in some command interpreters
# You can try other commands below to write npx --no -- commitlint --edit $1
# in the commit-msg file.
npx husky add .husky/commit-msg \"npx --no -- commitlint --edit '$1'\"
# or
npx husky add .husky/commit-msg "npx --no -- commitlint --edit $1"
```

Commit message convention:

-   https://www.conventionalcommits.org/en/v1.0.0/#specification
-   https://dev.to/i5han3/git-commit-message-convention-that-you-can-follow-1709
-   https://github.com/conventional-changelog/commitlint/#what-is-commitlint

### VS Code Settings

Apart from our onw personal settgins.json file, we can also create one in our codebase (a project speciffic file) in which we can enforce some settings, that will override / take precedence over the globals; the biggest advantage is that other developers using VS Code will have the same settings:

```
{
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll": true,
    "source.organizeImports": true
  }
}
```

### VS Code Debugger

First, we create a file called "launch.json" in our .vscode directory, to enable launching in different kinds of debug modes. The content of this file is also provided by next.js: https://nextjs.org/docs/advanced-features/debugging

These scripts can be found and ran from the "Run and Debug" tab in VS Code (ctrl + shift + d)

```
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Next.js: debug server-side",
      "type": "node-terminal",
      "request": "launch",
      "command": "npm run dev"
    },
    {
      "name": "Next.js: debug client-side",
      "type": "pwa-chrome",
      "request": "launch",
      "url": "http://localhost:3000"
    },
    {
      "name": "Next.js: debug full stack",
      "type": "node-terminal",
      "request": "launch",
      "command": "npm run dev",
      "console": "integratedTerminal",
      "serverReadyAction": {
        "pattern": "started server on .+, url: (https?://.+)",
        "uriFormat": "%s",
        "action": "debugWithChrome"
      }
    }
  ]
}
```

In case of source map error, also add this line:

```
"resolveSourceMapLocations": ["${workspaceFolder}/**", "!**/node_modules/**"]
```

## ENABLE INSPECTING OF SERVER-SIDE LOGS IN THE BROWSER

As also recommended by the next.js docs, automatic debugger for the dev environment can be added as welll, when running from the command line. This will enable you to see the server-side logs in the chrome developer tools.

First, install cross env to set environment variables the same way on linux / mac / windows on the comand line:

```
yarn add -D cross-env
```

Then, you can either update your dev script in package json, or create a separate one:

```
{
    "scripts": {
    "dev": "next dev",
    "dev:debug": "cross-env NODE_OPTIONS='--inspect' next dev",
  }
}
```

## Folder Structure

By default, the next app will not have a `src` folder, and the `pages` folder that it comes bundled with by default is placed at the root level. You can create a src folder to group your files (components, styles, types, utils, hooks, etc), and next also supports adding the pages folder here, but remember to remove it from the root level, so it's not duplicated; in case both `pages` and `src/pages` exist, the one from src will be ignored.

The `public` folder however can only be placed at the root level: https://nextjs.org/docs/advanced-features/src-directory
